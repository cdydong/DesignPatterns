
php面向对象的高级特性
主要学习常见的设计模式

一：命名空间 
    namespace
    和路径名相对应
    
二：自动加载
    __autoload($class);
    spl_autoload_register();


三：搭建一个简易的框架用来学习
   index.php是项目入口
   命名空间和文件相对路径保持一致
   
    base目录下的base.php是自动加载的方法
    application/controller目录下的index是测试自动加载是否成功的方法

四：简单的魔术方法
    base文件夹下的Magic.php中

五：常见的设计模式
    1：单例模式 Single.php  
        整个项目中，类只允许被new一次，太多的new会造成资源的浪费，例如，项目中只需要一个数据库连接

    2：工厂模式 Factory.php  
        根据不同的逻辑，可以使用工厂生成不同的对象
        如果一个类在项目中经常用到，单纯的new，在类改变时，很难去维护；而工厂模式只需要在工厂方法中改变就可以了

    3：注册器模式 Register.php

    4：原型模式
        原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。
        适用于大对象的创建，因为创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需内存拷贝即可。
        注：关于赋值和克隆 也就是浅复制和深复制（区别也就是是不是指向同一片内存）
            在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。
            在php语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现clone()方法是其中最简单，
            浅复制：被拷贝对象的所有变量都含有与原对象相同的值，而且对其他对象的引用仍然是指向原来的对象。
            深复制：被拷贝对象的所有的变量都含有与原来对象相同的值，除了那些引用其他对象的变量，那些引用其他对象的变量将指向一个被拷贝的新对象，而不再是原来那些被引用的对象
    
    5：数据对象映射模式：用了适配器之后去改写数据库操作 User.php  Factory.php

    6：适配器模式：统一三种数据库，databases.php中
        将不同的扩展封装成统一的api,例如php的mysql,mysqli,pdo ;缓存技术memcached redis file

    7：策略模式：Strategy.php TrainStrategy.php CarStrategy.php 
        对一组特定的行为或者算法进行封装，如果不用策略，就是使用if else去分辨，如果有新的行为，还要去改动。
        例如：果我需要在早晨从家里出发去上班，我可以有几个策略考虑：
        我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源
        
    8：观察者模式：Observer.php Orders.php CreateOrder.php 
        简单的应用场景，就是某个事件发生会有一连串的事件，如果不用观察者模式，这些事件会在同一个逻辑里，进而难以维护
        例如下个订单，送积分，送红包，送代金券
        再如，进入一个人公司，HR办社保，IT部门分配电脑，行政派发工位
        一个对象通过提供方法允许另一个对象即观察者 注册自己使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。
        这些观察者使用该信息执行的操作与可观察的对象无关。结果是对象可以相互对话，而不必了解原因。
        观察者模式是一种事件系统，意味着这一模式允许某个类观察另一个类的状态，当被观察的类状态发生改变的时候，观察类可以收到通知并且做出相应的动作;观察者模式为您提供了避免组件之间紧密耦
        
        上述的对象允许观察者注册自己很重要，这样本身改变时，注册的对象才能观察到变化，进而通知做出相应的动作

    9：装饰器模式：Area.php  AreaDecorator.php  动态添加和修改类的功能
        例如，一个类有某几个功能，如果要添加或者修改某个功能，传统的模式就是用继承，重新实现它的方法
        而装饰器模式不用如此，只需运行时添加装饰器的对象即可

    10：迭代器模式 ConcreteIterator.php ConcreteAggregate
        类继承PHP的Iterator接口
        1. 迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素。
        2. 相比传统的编程模式，迭代器模式可以隐藏遍历元素的所需操作。
        接口Iterator
        current() 返回当前元素
        key() 返回当前元素的键
        next() 向前移动到下一个元素
        rewind() 返回到迭代器的第一个元素



    

